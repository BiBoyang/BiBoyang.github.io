---
layout: post
title: "property 原理（一）：概述"
date: 2019-05-22 23:32:53 +0800
categories: jekyll update
---


# 0. 前言

在不使用属性的时候，我们往往会如下创建对象

```C++
@implementation ViewController
{
    NSString *aaa;   
}
```


但是这里有个问题：**对象的内存布局在编译期已经被固定了**。当你访问这个变量的时候，编译器就会将其替换为指针偏移量。这个偏移量是硬编码的，表示变量距离存放对象的内存区域的起始地址有多远。但是假如又加了一个变量，就要重新编译。

这种问题有两种解决方案:

1. 把实例变量当做一种存储偏移量的特殊变量交给类对象保管，然后偏移量会被在运行期中查找，如果类定义变了，那么偏移量也就变了；
2. 就是属性的方法。不直接访问实例变量，通过存取方法来处理。

# 1. 原理

本质上：**@property = 实例变量 + get 方法 + set 方法**。

当使用 self.xx 的时候，如果是设置值，那么就是在调用 setter 方法，如果是获取值，那就是在调用 getter 方法。这也是为什么 getter 方法中为何不能用 self.xx 的原因。

```C++
- (NSString *)name {
    return self.name;  // 错误的写法，会造成死循环
}
```

self.name 实际上就是执行了属性 name 的 getter 方法，getter 方法中又调用了self.name，会一直递归调用，直到程序崩溃.

编译器在编译期为实例变量添加的 setter、getter 方法。在 **runtime.h** 文件中，定义如下：

```C++
typedef struct objc_property *objc_property_t;
```

而 objc_property 是一个结构体，包括 name 和 attributes ，定义如下：

```C++
struct property_t {
    const char *name;
    const char *attributes;
};
```

这里 attributes 本质是 **objc_property_attribute_t**，定义了 property 的一些属性，定义如下：

```C++
/// Defines a property attribute
typedef struct {
    const char *name;           /**< The name of the attribute */
    const char *value;          /**< The value of the attribute (usually empty) */
} objc_property_attribute_t;
```

我们使用 **property_getAttributes** 方法，可以知道包括类型、原子性、内存语义和实例变量等。在后面我们可以看到相关代码。



# 2. clang 编译
我们也可以使用 clang 编译，将代码转换为 C++ 代码来查看。

原有代码如下：


```Cpp
#import "ViewController.h"

@interface ViewController ()
@property (nonatomic, copy) NSString *Boyang;
@end
@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    self.Boyang = @"bby_bby";   
}
```


编译之后如下（截取一部分，完整代码可以到[此处查看](https://github.com/BiBoyang/BoyangBlog/tree/master/Code/property)）：


```Cpp

extern "C" unsigned long OBJC_IVAR_$_ViewController$_Boyang;
struct ViewController_IMPL {
	struct UIViewController_IMPL UIViewController_IVARS;
	NSString *_Boyang;
};

```

接着往下看

```
static NSString * _I_ViewController_Boyang(ViewController * self, SEL _cmd) { return (*(NSString **)((char *)self + OBJC_IVAR_$_ViewController$_Boyang)); }
extern "C" __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);

static void _I_ViewController_setBoyang_(ViewController * self, SEL _cmd, NSString *Boyang) { 
objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct ViewController, _Boyang), (id)Boyang, 0, 1); }

```





我们可以发现， 编译器自动生成了一个 `ViewController_IMPL` 结构体，保存了名为 **_Boyang** 的实例变量。

然后会在 viewDidLoad 中自动生成它的 set 方法。

上面代码里多次提到 OFFSET ，我们可以直观的了解到：属性是通过运行时计算出 offset ，然后再以一个锚点（比如说 self），去计算出真正的位置。而如果使用实例变量，则这个 offset 是在编译的时候就直接确定了。

最明显的在这里：

```Cpp

static void _I_ViewController_setBoyang_(ViewController * self, SEL _cmd, NSString *Boyang) { objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct ViewController, _Boyang), (id)Boyang, 0, 1); }
```

使用 __OFFSETOFIVAR__ 来计算偏移量，计算出偏移量后使用 objc_setProperty 来设置实例变量 _Boyang 的值。

再往下看，有三块内容需要了解：

## _ivar_t


```Cpp
struct _ivar_t {
	unsigned long int *offset;  // pointer to ivar offset location
	const char *name;
	const char *type;
	unsigned int alignment;
	unsigned int  size;
};
static struct /*_ivar_list_t*/ {
	unsigned int entsize;  // sizeof(struct _prop_t)
	unsigned int count;
	struct _ivar_t ivar_list[1];
} _OBJC_$_INSTANCE_VARIABLES_ViewController __attribute__ ((used, section ("__DATA,__objc_const"))) = {
	sizeof(_ivar_t),
	1,
	{{(unsigned long int *)&OBJC_IVAR_$_ViewController$_Boyang, "_Boyang", "@\"NSString\"", 3, 8}}
};
```

_ivar_t 结构体表示每一个实例变量，记录了偏移值、名称、类型、对齐方式和大小，用于描述每一个实例变量。

这个 _ivar_list_t 结构体，表示类的实例变量列表，记录了实例变量的大小、个数、以及每一个实例变量描述；每在类中加入一个属性，编译器都会在 _ivar_list_t 变量中加入一个 _ivar_t 的实例变量描述。

## _objc_method 


```Cpp
struct _objc_method {
	struct objc_selector * _cmd;
	const char *method_type;
	void  *_imp;
};
......

static struct /*_method_list_t*/ {
	unsigned int entsize;  // sizeof(struct _objc_method)
	unsigned int method_count;
	struct _objc_method method_list[5];
} _OBJC_$_INSTANCE_METHODS_ViewController __attribute__ ((used, section ("__DATA,__objc_const"))) = {
	sizeof(_objc_method),
	5,
	{{(struct objc_selector *)"viewDidLoad", "v16@0:8", (void *)_I_ViewController_viewDidLoad},
	{(struct objc_selector *)"Boyang", "@16@0:8", (void *)_I_ViewController_Boyang},
	{(struct objc_selector *)"setBoyang:", "v24@0:8@16", (void *)_I_ViewController_setBoyang_},
	{(struct objc_selector *)"Boyang", "@16@0:8", (void *)_I_ViewController_Boyang},
	{(struct objc_selector *)"setBoyang:", "v24@0:8@16", (void *)_I_ViewController_setBoyang_}}
};
```


_objc_method 结构体描述了每一个实例方法，包括一个 SEL 类型的指针、方法类型和方法实现。
_method_list_t 结构体表示类的实例方法列表，记录了每一个实例方法的大小、实例方法个数以及具体的实例方法描述，每加入一个属性则会在 _method_list_t 中增加 setter 与 getter 方法的描述。

## _prop_t

```Cpp
struct _prop_t {
	const char *name;
	const char *attributes;
};
```

_prop_t 结构体描述了每一个属性，包括名称和属性值，其实就是 property_t 在 clang 中的表示。

## 小结


以上是使用 clang 转换过的代码得到的一些信息，不过我们要注意，使用 clang 和实际的底层实现，可能表现的并非完全一致， clang 本身会做很多优化，添加很多代码，如果看过 clang 转换 block 代码的话，可能会更加理解。
