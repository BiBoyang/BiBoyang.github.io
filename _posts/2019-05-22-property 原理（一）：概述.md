---
layout: post
title: "property 原理（一）：概述"
date: 2019-05-22 23:32:53 +0800
categories: jekyll update
---


# 0. 前言

在不使用属性的时候，我们往往会如下创建对象

```C++
@implementation ViewController
{
    NSString *aaa;   
}
```


但是这里有个问题：**对象的内存布局在编译期已经被固定了**。当你访问这个变量的时候，编译器就会将其替换为指针偏移量。这个偏移量是硬编码的，表示变量距离存放对象的内存区域的起始地址有多远。但是假如又加了一个变量，就要重新编译。

这种问题有两种解决方案:

1. 把实例变量当做一种存储偏移量的特殊变量交给类对象保管，然后偏移量会被在运行期中查找，如果类定义变了，那么偏移量也就变了；
2. 就是属性的方法。不直接访问实例变量，通过存取方法来处理。

# 1. 原理

本质上：**@property = 实例变量 + get 方法 + set 方法**。

当使用 self.xx 的时候，如果是设置值，那么就是在调用 setter 方法，如果是获取值，那就是在调用 getter 方法。这也是为什么 getter 方法中为何不能用 self.xx 的原因。

```C++
- (NSString *)name {
    return self.name;  // 错误的写法，会造成死循环
}
```

self.name 实际上就是执行了属性 name 的 getter 方法，getter 方法中又调用了self.name，会一直递归调用，直到程序崩溃.

编译器在编译期为实例变量添加的 setter、getter 方法。在 **runtime.h** 文件中，定义如下：

```C++
typedef struct objc_property *objc_property_t;
```

而 objc_property 是一个结构体，包括 name 和 attributes ，定义如下：

```C++
struct property_t {
    const char *name;
    const char *attributes;
};
```

这里 attributes 本质是 **objc_property_attribute_t**，定义了 property 的一些属性，定义如下：

```C++
/// Defines a property attribute
typedef struct {
    const char *name;           /**< The name of the attribute */
    const char *value;          /**< The value of the attribute (usually empty) */
} objc_property_attribute_t;
```

我们使用 **property_getAttributes** 方法，可以知道包括类型、原子性、内存语义和实例变量等。在后面我们可以看到相关代码。