---
layout: post
title:  "分析 runtime 创建销毁"
date:   2025-12-26 23:32:53 +0800
categories: jekyll update
---



基于 objc4-950 版本

上一篇文章从结构的方向解析了一些 runtime 的源码,这次我们从对象的生命流程上分析一下.

## 初始化流程

一般来说,我们使用如下方法创建一个对象
```
id obj = [[MyClass alloc] init];
```

很简单,直接从源码来看

```
+ (id)alloc {
    return _objc_rootAlloc(self);
}
id _objc_rootAlloc(Class cls)
{
    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);
}

```

这里很简单,和之前的版本也是一样的,但是接下来,在新版本中发生了改变:

```
static ALWAYS_INLINE id
callAlloc(Class cls, bool checkNil, bool allocWithZone=false)
{
    if (slowpath(checkNil && !cls)) return nil;
    if (fastpath(!cls->ISA()->hasCustomAWZ())) {
        return _objc_rootAllocWithZone(cls, nil);
    }
    if (allocWithZone) {
        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);
    }
    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));
}
```

在这里,runtime 先进行一个判断:检查 cls 是否为 nil,如果是则直接返回 nil,`slowpath`是告知 CPU 这个分支这个情况极少出现.

然后在 `fastpath` 分支中,大多数类不会重写 +alloc/+allocWithZone（AWZ），因此直接走底层 C 分配函数，绕过 objc_msgSend。

然后接着判断 `if (allocWithZone) `,假如该类自定义了 AWZ，就必须尊重类的实现，通过消息发送调用`[cls allocWithZone:nil]`;最后如果都没有,那就直接进入 `[cls alloc]`.

这里的 `hasCustomAWZ` ,是一个标志位:
```
#if FAST_CACHE_HAS_DEFAULT_AWZ
    bool hasCustomAWZ() const {
        return !cache.getBit(FAST_CACHE_HAS_DEFAULT_AWZ);
    }
#else
    bool hasCustomAWZ() const {
        return !(bits.data()->flags & RW_HAS_DEFAULT_AWZ);
    }
```

`FAST_CACHE_HAS_DEFAULT_AWZ`表示这个对象的“类或其父类使用默认的 +alloc/+allocWithZone 实现”，位存储在元类的“快速缓存”结构中，读取非常便宜，适合在分配入口热路径使用;`RW_HAS_DEFAULT_AWZ`是 class_rw_t.flags 中的同义语义位，存储在 rw 视图里；当不启用快缓存位的情况下，就用它作为信息来源。




* 小结:
     这部分是对象创建流程中,优化最大的一部分,`slowpath/fastpath` 是分支预测宏，用来强化“nil 很少”“无自定义 AWZ 很多”的假设，从而让绝大多数类的分配走直通 C 实现，既快又不改变语义,跳过了多次 `objc_msgSend`；而有自定义 AWZ 的类则保留消息发送以保证行为一致性。


#### _objc_rootAllocWithZone

其余几个分支都是走 objc_msgSend 方法,所以可以单独来看它

```
id _objc_rootAllocWithZone(Class cls, objc_zone_t)
{
    cls->realizeIfNeeded();
    return _class_createInstance_realized(cls, 0, OBJECT_CONSTRUCT_CALL_BADALLOC);
}
```

这里cls->realizeIfNeeded()是在分配前确保类已 realize（加载并准备好 ro/rw 元数据、方法缓存等）。

然后接着进入下一步:

```
static ALWAYS_INLINE id
_class_createInstance_realized(Class cls, size_t extraBytes,
                               int construct_flags = OBJECT_CONSTRUCT_NONE,
                               bool cxxConstruct = true,
                               size_t *outAllocatedSize = nil)
{
    ASSERT(cls->isRealized());

    // Read class's info bits all at once for performance
    bool hasCxxCtor = cxxConstruct && cls->hasCxxCtor();
    bool hasCxxDtor = cls->hasCxxDtor();
    bool fast = cls->canAllocNonpointer();
    size_t size;

    size = cls->instanceSize(extraBytes);
    if (outAllocatedSize) *outAllocatedSize = size;

    id obj = objc::malloc_instance(size, cls);
    if (slowpath(!obj)) {
        if (construct_flags & OBJECT_CONSTRUCT_CALL_BADALLOC) {
            return _objc_callBadAllocHandler(cls);
        }
        return nil;
    }

    if (fast) {
        obj->initInstanceIsa(cls, hasCxxDtor);
    } else {
        obj->initIsa(cls);
    }

    if (fastpath(!hasCxxCtor)) {
        return obj;
    }

    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;
    return object_cxxConstructFromClass(obj, cls, construct_flags);
}
```

在这里,我们先把 `hasCxxCtor/hasCxxDtor/canAllocNonpointer` 读到局部变量，减少重复读取与潜在的内存序开销，并便于编译器做寄存器优化;
然后 `size = cls->instanceSize(extraBytes);`快速获取内存对齐后的 size,接着统一使用`objc::malloc_instance`来分配对象.

接着来看
```
    if (fast) {
        obj->initInstanceIsa(cls, hasCxxDtor);
    } else {
        obj->initIsa(cls);
    }
```

这里 fast 表示“这个类的实例是否允许使用非指针 isa”,举个例子,为了加快速度,isa 字段里面可能以位域形式承载更多状态（如是否有 C++ 析构、是否被弱引用、是否正在释放、内联引用计数等）,这就是非指针 isa;如果不被允许,则使用指针 isa,里面只存类指针,其他信息要从 side table 中获取,牺牲一点性能以保证兼容性与安全性。


接着往下

```
if (fastpath(!hasCxxCtor)) {
    return obj;
}
construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;
return object_cxxConstructFromClass(obj, cls, construct_flags);
```
如果类没有 C++ 构造函数（hasCxxCtor 为假），直接返回对象;如果有 C++ 构造，则调用 object_cxxConstructFromClass.

在接着,返回上层调用链,继续执行 init

```
- (id)init {
    return _objc_rootInit(self);
}
id
_objc_rootInit(id obj)
{
    return obj;
}
```

这里就算完成了对象的初始化流程.

#### 总结

在最新版本下,一个对象的初始化时,绝大部分 alloc 方法会跳过 objc_msgSend，直接走 C 函数分配;同时在 fast 路径下,一次写入非指针 isa，携带 has_cxx_dtor、可能的 index/shiftcls、inline RC 等状态，后续 retain/release/析构更快;通过分支预测宏 fastpath/slowpath 和 ALWAYS_INLINE 帮助编译器/CPU把热点路径紧凑布局，提升冷启动与普遍分配性能。


## dealloc

接着来探究一下对象的销毁流程.

对象的销毁时,runtime 会调用 dealloc 方法.

```
- (void)dealloc {
    _objc_rootDealloc(self);
}
void _objc_rootDealloc(id obj) {
    ASSERT(obj);
    obj->rootDealloc();
}


inline void objc_object::rootDealloc() {
    if (isTaggedPointer()) return;  // fixme necessary?

#if !ISA_HAS_INLINE_RC
    _object_dispose_nonnull_realized((id)this);
#else
    if (fastpath(isa().nonpointer                     &&
                 !isa().weakly_referenced             &&
                 !isa().has_assoc                     &&
#if ISA_HAS_CXX_DTOR_BIT
                 !isa().has_cxx_dtor                  &&
#else
                 !isa().getClass(false)->hasCxxDtor() &&
#endif
                 !isa().has_sidetable_rc))
    {
        assert(!sidetable_present());
        free(this);
    } 
    else {
        _object_dispose_nonnull_realized((id)this);
    }
#endif // ISA_HAS_INLINE_RC
}
```

这里作者非常幽默的写下了一个注释`if (isTaggedPointer()) return;  // fixme necessary?`,质疑这行是否真的需要,因为理论上不会给 Tagged Pointer 发送 `-dealloc`

