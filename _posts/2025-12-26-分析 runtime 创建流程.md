---
layout: post
title:  "分析 runtime 创建销毁"
date:   2025-12-26 23:32:53 +0800
categories: jekyll update
---



基于 objc4-950 版本

上一篇文章从结构的方向解析了一些 runtime 的源码,这次我们从对象的生命流程上分析一下.

## 初始化流程

一般来说,我们使用如下方法创建一个对象
```
id obj = [[MyClass alloc] init];
```

很简单,直接从源码来看

```
+ (id)alloc {
    return _objc_rootAlloc(self);
}
id _objc_rootAlloc(Class cls)
{
    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);
}

```

这里很简单,和之前的版本也是一样的,但是接下来,在新版本中发生了改变:

```
static ALWAYS_INLINE id
callAlloc(Class cls, bool checkNil, bool allocWithZone=false)
{
    if (slowpath(checkNil && !cls)) return nil;
    if (fastpath(!cls->ISA()->hasCustomAWZ())) {
        return _objc_rootAllocWithZone(cls, nil);
    }
    if (allocWithZone) {
        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);
    }
    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));
}
```

在这里,runtime 先进行一个判断:检查 cls 是否为 nil,如果是则直接返回 nil,`slowpath`是告知 CPU 这个分支这个情况极少出现.

然后在 `fastpath` 分支中,大多数类不会重写 +alloc/+allocWithZone（AWZ），因此直接走底层 C 分配函数，绕过 objc_msgSend。

然后接着判断 `if (allocWithZone) `,假如该类自定义了 AWZ，就必须尊重类的实现，通过消息发送调用`[cls allocWithZone:nil]`;最后如果都没有,那就直接进入 `[cls alloc]`.

这里的 `hasCustomAWZ` ,是一个标志位:
```
#if FAST_CACHE_HAS_DEFAULT_AWZ
    bool hasCustomAWZ() const {
        return !cache.getBit(FAST_CACHE_HAS_DEFAULT_AWZ);
    }
#else
    bool hasCustomAWZ() const {
        return !(bits.data()->flags & RW_HAS_DEFAULT_AWZ);
    }
```

`FAST_CACHE_HAS_DEFAULT_AWZ`表示这个对象的“类或其父类使用默认的 +alloc/+allocWithZone 实现”，位存储在元类的“快速缓存”结构中，读取非常便宜，适合在分配入口热路径使用;`RW_HAS_DEFAULT_AWZ`是 class_rw_t.flags 中的同义语义位，存储在 rw 视图里；当不启用快缓存位的情况下，就用它作为信息来源。




* 小结:
     这部分是对象创建流程中,优化最大的一部分,`slowpath/fastpath` 是分支预测宏，用来强化“nil 很少”“无自定义 AWZ 很多”的假设，从而让绝大多数类的分配走直通 C 实现，既快又不改变语义,跳过了多次 `objc_msgSend`；而有自定义 AWZ 的类则保留消息发送以保证行为一致性。


#### _objc_rootAllocWithZone

其余几个分支都是走 objc_msgSend 方法,所以可以单独来看它

```
id _objc_rootAllocWithZone(Class cls, objc_zone_t)
{
    cls->realizeIfNeeded();
    return _class_createInstance_realized(cls, 0, OBJECT_CONSTRUCT_CALL_BADALLOC);
}
```

这里cls->realizeIfNeeded()是在分配前确保类已 realize（加载并准备好 ro/rw 元数据、方法缓存等）。

然后接着进入下一步:

```
static ALWAYS_INLINE id
_class_createInstance_realized(Class cls, size_t extraBytes,
                               int construct_flags = OBJECT_CONSTRUCT_NONE,
                               bool cxxConstruct = true,
                               size_t *outAllocatedSize = nil)
{
    ASSERT(cls->isRealized());

    // Read class's info bits all at once for performance
    bool hasCxxCtor = cxxConstruct && cls->hasCxxCtor();
    bool hasCxxDtor = cls->hasCxxDtor();
    bool fast = cls->canAllocNonpointer();
    size_t size;

    size = cls->instanceSize(extraBytes);
    if (outAllocatedSize) *outAllocatedSize = size;

    id obj = objc::malloc_instance(size, cls);
    if (slowpath(!obj)) {
        if (construct_flags & OBJECT_CONSTRUCT_CALL_BADALLOC) {
            return _objc_callBadAllocHandler(cls);
        }
        return nil;
    }

    if (fast) {
        obj->initInstanceIsa(cls, hasCxxDtor);
    } else {
        obj->initIsa(cls);
    }

    if (fastpath(!hasCxxCtor)) {
        return obj;
    }

    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;
    return object_cxxConstructFromClass(obj, cls, construct_flags);
}
```

在这里,我们先把 `hasCxxCtor/hasCxxDtor/canAllocNonpointer` 读到局部变量，减少重复读取与潜在的内存序开销，并便于编译器做寄存器优化;
然后 `size = cls->instanceSize(extraBytes);`快速获取内存对齐后的 size,接着统一使用`objc::malloc_instance`来分配对象.

接着来看
```
    if (fast) {
        obj->initInstanceIsa(cls, hasCxxDtor);
    } else {
        obj->initIsa(cls);
    }
```

这里 fast 表示“这个类的实例是否允许使用非指针 isa”,举个例子,为了加快速度,isa 字段里面可能以位域形式承载更多状态（如是否有 C++ 析构、是否被弱引用、是否正在释放、内联引用计数等）,这就是非指针 isa;如果不被允许,则使用指针 isa,里面只存类指针,其他信息要从 side table 中获取,牺牲一点性能以保证兼容性与安全性。


接着往下

```
if (fastpath(!hasCxxCtor)) {
    return obj;
}
construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;
return object_cxxConstructFromClass(obj, cls, construct_flags);
```
如果类没有 C++ 构造函数（hasCxxCtor 为假），直接返回对象;如果有 C++ 构造，则调用 object_cxxConstructFromClass.

在接着,返回上层调用链,继续执行 init

```
- (id)init {
    return _objc_rootInit(self);
}
id
_objc_rootInit(id obj)
{
    return obj;
}
```

这里就算完成了对象的初始化流程.

#### 总结

在最新版本下,一个对象的初始化时,绝大部分 alloc 方法会跳过 objc_msgSend，直接走 C 函数分配;同时在 fast 路径下,一次写入非指针 isa，携带 has_cxx_dtor、可能的 index/shiftcls、inline RC 等状态，后续 retain/release/析构更快;通过分支预测宏 fastpath/slowpath 和 ALWAYS_INLINE 帮助编译器/CPU把热点路径紧凑布局，提升冷启动与普遍分配性能。


## dealloc

接着来探究一下对象的销毁流程.我们知道 iOS 使用的是自动引用计数,那么实际上 dealloc 的开始流程应该是从引用计数清零的时候开始的.

#### release

```
ALWAYS_INLINE bool
objc_object::rootRelease(bool performDealloc, objc_object::RRVariant variant) {
    if (slowpath(isTaggedPointer())) return false;
    bool sideTableLocked = false;

    isa_t newisa, oldisa;

    oldisa = LoadExclusive(&isa().bits);
    1----------1
    if (variant == RRVariant::FastOrMsgSend) {

        if (slowpath(oldisa.getDecodedClass(false)->hasCustomRR())) {
            ClearExclusive(&isa().bits);
            if (oldisa.getDecodedClass(false)->canCallSwiftRR()) {
                swiftRelease.load(memory_order_relaxed)((id)this);
                return true;
            }
            ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(release));
            return true;
        }
    }
    1----------1
    
    2----------2
    if (slowpath(!oldisa.nonpointer)) {
        // a Class is a Class forever, so we can perform this check once
        // outside of the CAS loop
        if (oldisa.getDecodedClass(false)->isMetaClass()) {
            ClearExclusive(&isa().bits);
            return false;
        }
    }
    2----------2
    
    3----------3
#if !ISA_HAS_INLINE_RC
    // Without inline ref counts, we always use sidetables
    ClearExclusive(&isa().bits);
    return sidetable_release(sideTableLocked, performDealloc);
#else
retry:
    do {
        newisa = oldisa;
        if (slowpath(!newisa.nonpointer)) {
            ClearExclusive(&isa().bits);
            return sidetable_release(sideTableLocked, performDealloc);
        }
        if (slowpath(newisa.isDeallocating())) {
            ClearExclusive(&isa().bits);
            if (sideTableLocked) {
                ASSERT(variant == RRVariant::Full);
                sidetable_unlock();
            }
            return false;
        }

        // don't check newisa.fast_rr; we already called any RR overrides
        uintptr_t carry;
        newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc--
        if (slowpath(carry)) {
            // don't ClearExclusive()
            goto underflow;
        }
    } while (slowpath(!StoreReleaseExclusive(&isa().bits, &oldisa.bits, newisa.bits)));

    if (slowpath(newisa.isDeallocating()))
        goto deallocate;

    if (variant == RRVariant::Full) {
        if (slowpath(sideTableLocked)) sidetable_unlock();
    } else {
        ASSERT(!sideTableLocked);
    }
    return false;
3----------3

4----------4
 underflow:
    // newisa.extra_rc-- underflowed: borrow from side table or deallocate

    // abandon newisa to undo the decrement
    newisa = oldisa;

    if (slowpath(newisa.has_sidetable_rc)) {
        if (variant != RRVariant::Full) {
            ClearExclusive(&isa().bits);
            return rootRelease_underflow(performDealloc);
        }

        // Transfer retain count from side table to inline storage.

        if (!sideTableLocked) {
            ClearExclusive(&isa().bits);
            sidetable_lock();
            sideTableLocked = true;
            // Need to start over to avoid a race against 
            // the nonpointer -> raw pointer transition.
            oldisa = LoadExclusive(&isa().bits);
            goto retry;
        }

        // Try to remove some retain counts from the side table.        
        auto borrow = sidetable_subExtraRC_nolock(RC_HALF);

        bool emptySideTable = borrow.remaining == 0; // we'll clear the side table if no refcounts remain there

        if (borrow.borrowed > 0) {
            // Side table retain count decreased.
            // Try to add them to the inline count.
            bool didTransitionToDeallocating = false;
            newisa.extra_rc = borrow.borrowed - 1;  // redo the original decrement too
            newisa.has_sidetable_rc = !emptySideTable;

            bool stored = StoreReleaseExclusive(&isa().bits, &oldisa.bits, newisa.bits);

            if (!stored && oldisa.nonpointer) {
                // Inline update failed. 
                // Try it again right now. This prevents livelock on LL/SC 
                // architectures where the side table access itself may have 
                // dropped the reservation.
                uintptr_t overflow;
                newisa.bits =
                    addc(oldisa.bits, RC_ONE * (borrow.borrowed-1), 0, &overflow);
                newisa.has_sidetable_rc = !emptySideTable;
                if (!overflow) {
                    stored = StoreReleaseExclusive(&isa().bits, &oldisa.bits, newisa.bits);
                    if (stored) {
                        didTransitionToDeallocating = newisa.isDeallocating();
                    }
                }
            }

            if (!stored) {
                // Inline update failed.
                // Put the retains back in the side table.
                ClearExclusive(&isa().bits);
                sidetable_addExtraRC_nolock(borrow.borrowed);
                oldisa = LoadExclusive(&isa().bits);
                goto retry;
            }

            // Decrement successful after borrowing from side table.
            if (emptySideTable)
                sidetable_clearExtraRC_nolock();

            if (!didTransitionToDeallocating) {
                if (slowpath(sideTableLocked)) sidetable_unlock();
                return false;
            }
        }
        else {
            // Side table is empty after all. Fall-through to the dealloc path.
        }
    }
4----------4
5----------5
deallocate:
    // Really deallocate.

    ASSERT(newisa.isDeallocating());
    ASSERT(isa().isDeallocating());

    if (slowpath(sideTableLocked)) sidetable_unlock();

    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);

    if (performDealloc) {
        this->performDealloc();
    }
    5----------5
    return true;
#endif // ISA_HAS_INLINE_RC
}
```

这是一段非常复杂的 release 流程,我在代码中进行了标注,粗略的讲一下,

1. 当在 MRC 或者桥接的场景化,有可能自定义了-retain/-release,所以要通过 hasCustomRR
来进行判断.如果没有自定义：直接向下走 rootRelease 的内联计数/侧表逻辑（最快路径）。
若有自定义，则先判断是否可以走 Swift 引用计数,能走则调用 swiftRelease,若无,则发送 release 消息.

2. 接着通过 `slowpath(!oldisa.nonpointer)`判断是否是元类,如果是,则不做实例释放.

3. 接着做 **非指针 isa 的内联计数递减**:原子加载 isa，尝试 extra_rc--。若成功且未转入“正在销毁”，释放结束；若借不到计数则进入“下溢”处理。

4. 然后进行下溢处理（借还侧表计数）:若 has_sidetable_rc 为真，持锁从侧表借回一半计数 [sidetable_subExtraRC_nolock(RC_HALF)] 并重做递减；若侧表为空，转入“正在销毁”状态。 
5.  进入“正在销毁”状态:当内联计数为 0 且没有侧表计数时，开始进入 performDealloc 方法


#### dealloc



对象的销毁时,runtime 会调用 dealloc 方法.

```
- (void)dealloc {
    _objc_rootDealloc(self);
}
void _objc_rootDealloc(id obj) {
    ASSERT(obj);
    obj->rootDealloc();
}


inline void objc_object::rootDealloc() {
    if (isTaggedPointer()) return;  // fixme necessary?

#if !ISA_HAS_INLINE_RC
    _object_dispose_nonnull_realized((id)this);
#else
    if (fastpath(isa().nonpointer                     &&
                 !isa().weakly_referenced             &&
                 !isa().has_assoc                     &&
#if ISA_HAS_CXX_DTOR_BIT
                 !isa().has_cxx_dtor                  &&
#else
                 !isa().getClass(false)->hasCxxDtor() &&
#endif
                 !isa().has_sidetable_rc))
    {
        assert(!sidetable_present());
        free(this);
    } 
    else {
        _object_dispose_nonnull_realized((id)this);
    }
#endif // ISA_HAS_INLINE_RC
}
```

这里作者非常幽默的写下了一个注释`if (isTaggedPointer()) return;  // fixme necessary?`,质疑这行是否真的需要,因为理论上不会给 Tagged Pointer 发送 `-dealloc`

